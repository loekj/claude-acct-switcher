#!/usr/bin/env bash
# vdm - Van Damme-o-Matic
# Manages multiple Claude Code OAuth credential profiles via macOS Keychain.
# All running Claude Code sessions share the same Keychain entry,
# so switching here affects every open tab.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")")" && pwd)"
ACCOUNTS_DIR="$SCRIPT_DIR/accounts"
KEYCHAIN_ACCOUNT="$(whoami)"
DASHBOARD_PORT="${CSW_PORT:-3333}"
PROXY_PORT="${CSW_PROXY_PORT:-3334}"
DASHBOARD_PID_FILE="$SCRIPT_DIR/.dashboard.pid"
CONFIG_FILE="$SCRIPT_DIR/config.json"
ACTIVITY_LOG_FILE="$SCRIPT_DIR/activity-log.json"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

mkdir -p "$ACCOUNTS_DIR"

# ─────────────────────────────────────────────────────────
# Keychain service auto-detection
# ─────────────────────────────────────────────────────────

detect_keychain_service() {
  # Try the known default first
  if security find-generic-password -a "$KEYCHAIN_ACCOUNT" -s "Claude Code-credentials" -w &>/dev/null; then
    echo "Claude Code-credentials"
    return
  fi
  # Broader search for any Claude credential
  local svc
  svc=$(security dump-keychain 2>/dev/null | grep -A4 '"svce"' | grep -i claude | head -1 | sed -n 's/.*"svce"<blob>="\([^"]*\)".*/\1/p') || true
  if [[ -n "$svc" ]]; then
    echo "$svc"
    return
  fi
  # Fallback
  echo "Claude Code-credentials"
}

KEYCHAIN_SERVICE="$(detect_keychain_service)"

# ─────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────

read_keychain() {
  security find-generic-password -s "$KEYCHAIN_SERVICE" -w 2>/dev/null
}

write_keychain() {
  local creds="$1"
  # Delete existing entry first (security won't overwrite)
  security delete-generic-password -s "$KEYCHAIN_SERVICE" -a "$KEYCHAIN_ACCOUNT" 2>/dev/null || true
  # Write new entry
  security add-generic-password -s "$KEYCHAIN_SERVICE" -a "$KEYCHAIN_ACCOUNT" -w "$creds"
}

get_active_fingerprint() {
  local creds
  creds=$(read_keychain 2>/dev/null) || return 1
  echo "$creds" | python3 -c "
import sys, json, hashlib
d = json.load(sys.stdin)
token = d.get('claudeAiOauth', {}).get('accessToken', '')
print(hashlib.sha256(token.encode()).hexdigest()[:16])
" 2>/dev/null
}

get_profile_fingerprint() {
  local file="$1"
  python3 -c "
import sys, json, hashlib
with open('$file') as f:
    d = json.load(f)
token = d.get('claudeAiOauth', {}).get('accessToken', '')
print(hashlib.sha256(token.encode()).hexdigest()[:16])
" 2>/dev/null
}

get_profile_info() {
  local file="$1"
  python3 -c "
import sys, json, datetime
with open('$file') as f:
    d = json.load(f)
oauth = d.get('claudeAiOauth', {})
sub = oauth.get('subscriptionType', 'unknown')
tier = oauth.get('rateLimitTier', 'unknown')
expires = oauth.get('expiresAt', 0)
exp_str = datetime.datetime.fromtimestamp(expires/1000).strftime('%Y-%m-%d %H:%M') if expires else 'unknown'
# Clean up tier display
tier_short = tier.split('_')[-1] if '_' in tier else tier
print(f'{sub}|{tier_short}|{exp_str}')
" 2>/dev/null
}

fetch_account_email() {
  local token="$1"
  local org_name
  org_name=$(curl -s \
    -H "Authorization: Bearer $token" \
    -H "anthropic-beta: oauth-2025-04-20" \
    -H "User-Agent: claude-code/vdm" \
    "https://api.anthropic.com/api/oauth/claude_cli/roles" 2>/dev/null \
    | python3 -c "
import sys, json, re
try:
    d = json.load(sys.stdin)
    name = d.get('organization_name', '')
    # Extract email from 'user@email.com'\''s Organization'
    match = re.match(r\"(.+?)(?:'s Organization| Organization)$\", name)
    if match:
        print(match.group(1))
    else:
        print(name)
except:
    pass
" 2>/dev/null)
  echo "$org_name"
}

format_sub_type() {
  case "$1" in
    max) echo -e "${BOLD}${CYAN}MAX${NC}" ;;
    pro) echo -e "${BOLD}${BLUE}PRO${NC}" ;;
    free) echo -e "${DIM}FREE${NC}" ;;
    *) echo -e "${DIM}$1${NC}" ;;
  esac
}

# ─────────────────────────────────────────────────────────
# Activity log (shared with dashboard)
# ─────────────────────────────────────────────────────────

log_activity() {
  local type="$1"
  shift
  # Build JSON entry: { "ts": <epoch_ms>, "type": "<type>", ...extra }
  python3 -c "
import json, time, sys, os

log_file = '$ACTIVITY_LOG_FILE'
entry = {'ts': int(time.time() * 1000), 'type': '$type'}

# Parse extra key=value args
for arg in sys.argv[1:]:
    if '=' in arg:
        k, v = arg.split('=', 1)
        entry[k] = v

# Load existing log
log = []
try:
    with open(log_file) as f:
        log = json.load(f)
except:
    pass

log.insert(0, entry)
log = log[:200]  # max 200 entries

with open(log_file, 'w') as f:
    json.dump(log, f, indent=2)
" "$@" 2>/dev/null || true
}

# ─────────────────────────────────────────────────────────
# Config helpers
# ─────────────────────────────────────────────────────────

read_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    cat "$CONFIG_FILE"
  else
    echo '{"autoSwitch":true,"proxyEnabled":true,"rotationStrategy":"sticky","rotationIntervalMin":60}'
  fi
}

write_config() {
  echo "$1" > "$CONFIG_FILE"
}

get_config_value() {
  local key="$1"
  read_config | python3 -c "import sys,json; print(json.load(sys.stdin).get('$key', ''))" 2>/dev/null
}

set_config_value() {
  local key="$1"
  local value="$2"
  python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        cfg = json.load(f)
except:
    cfg = {'autoSwitch': True, 'proxyEnabled': True}
cfg['$key'] = $value
with open('$CONFIG_FILE', 'w') as f:
    json.dump(cfg, f, indent=2)
" 2>/dev/null
}

get_config_string() {
  local key="$1"
  read_config | python3 -c "import sys,json; print(json.load(sys.stdin).get('$key', ''))" 2>/dev/null
}

set_config_string() {
  local key="$1"
  local value="$2"
  python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        cfg = json.load(f)
except:
    cfg = {}
cfg['$key'] = '$value'
with open('$CONFIG_FILE', 'w') as f:
    json.dump(cfg, f, indent=2)
" 2>/dev/null
}

set_config_number() {
  local key="$1"
  local value="$2"
  python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        cfg = json.load(f)
except:
    cfg = {}
cfg['$key'] = $value
with open('$CONFIG_FILE', 'w') as f:
    json.dump(cfg, f, indent=2)
" 2>/dev/null
}

# ─────────────────────────────────────────────────────────
# Commands
# ─────────────────────────────────────────────────────────

cmd_add() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    echo -e "${RED}Usage: vdm add <name>${NC}"
    echo "  Saves the currently logged-in credentials as a named profile."
    echo "  Example: vdm add work-account"
    return 1
  fi

  # Sanitize name
  name=$(echo "$name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local file="$ACCOUNTS_DIR/${name}.json"

  local creds
  creds=$(read_keychain) || {
    echo -e "${RED}No credentials found in Keychain. Run 'claude login' first.${NC}"
    return 1
  }

  # Get profile info for display
  echo "$creds" > "$file"
  chmod 600 "$file"

  local info
  info=$(get_profile_info "$file")
  local sub_type=$(echo "$info" | cut -d'|' -f1)
  local tier=$(echo "$info" | cut -d'|' -f2)
  local expires=$(echo "$info" | cut -d'|' -f3)

  # Auto-fetch email from API
  local token
  token=$(echo "$creds" | python3 -c "import sys,json; print(json.load(sys.stdin)['claudeAiOauth']['accessToken'])" 2>/dev/null)
  local email=""
  if [[ -n "$token" ]]; then
    email=$(fetch_account_email "$token")
  fi
  if [[ -n "$email" ]]; then
    echo "$email" > "$ACCOUNTS_DIR/${name}.label"
  fi

  echo -e "${GREEN}✓${NC} Saved profile ${BOLD}$name${NC}"
  if [[ -n "$email" ]]; then
    echo -e "  Email: ${CYAN}$email${NC}"
  fi
  echo -e "  Plan: $(format_sub_type "$sub_type")  Tier: ${tier}"
  echo -e "  Token expires: ${DIM}$expires${NC}"

  log_activity "account-discovered" "name=$name" "label=${email:-$name}"
}

cmd_label() {
  local name="${1:-}"
  local label="${2:-}"
  if [[ -z "$name" || -z "$label" ]]; then
    echo -e "${RED}Usage: vdm label <name> <label>${NC}"
    echo "  Gives a profile a human-readable label (e.g. email or description)."
    echo "  Example: vdm label work-account john@company.com"
    return 1
  fi

  name=$(echo "$name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local file="$ACCOUNTS_DIR/${name}.json"
  if [[ ! -f "$file" ]]; then
    echo -e "${RED}Profile '$name' not found.${NC}"
    return 1
  fi

  echo "$label" > "$ACCOUNTS_DIR/${name}.label"
  echo -e "${GREEN}✓${NC} Labeled ${BOLD}$name${NC} as ${CYAN}$label${NC}"

  log_activity "account-renamed" "name=$name" "label=$label"
}

cmd_list() {
  local active_fp
  active_fp=$(get_active_fingerprint 2>/dev/null) || active_fp=""

  local profiles=("$ACCOUNTS_DIR"/*.json)
  if [[ ! -f "${profiles[0]:-}" ]]; then
    echo -e "${YELLOW}No saved profiles. Use 'vdm add <name>' to save the current account.${NC}"
    return 0
  fi

  echo ""
  echo -e "${BOLD}  Van Damme-o-Matic Accounts${NC}"
  echo -e "  ─────────────────────────────────────────────"

  for file in "${profiles[@]}"; do
    local name=$(basename "$file" .json)
    local fp=$(get_profile_fingerprint "$file" 2>/dev/null)
    local info=$(get_profile_info "$file" 2>/dev/null)
    local sub_type=$(echo "$info" | cut -d'|' -f1)
    local tier=$(echo "$info" | cut -d'|' -f2)
    local expires=$(echo "$info" | cut -d'|' -f3)
    local label_file="$ACCOUNTS_DIR/${name}.label"
    local label=""
    [[ -f "$label_file" ]] && label=$(cat "$label_file")

    if [[ "$fp" == "$active_fp" ]]; then
      echo -e "  ${GREEN}▸ ${BOLD}$name${NC}  $(format_sub_type "$sub_type")  ${GREEN}← active${NC}"
    else
      echo -e "    ${BOLD}$name${NC}  $(format_sub_type "$sub_type")"
    fi
    if [[ -n "$label" ]]; then
      echo -e "      ${DIM}$label${NC}"
    fi
    echo -e "      ${DIM}tier: $tier  expires: $expires${NC}"
  done

  echo ""
}

cmd_switch() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    # Interactive mode: show numbered list
    local profiles=("$ACCOUNTS_DIR"/*.json)
    if [[ ! -f "${profiles[0]:-}" ]]; then
      echo -e "${YELLOW}No saved profiles. Use 'vdm add <name>' to save the current account.${NC}"
      return 1
    fi

    local active_fp
    active_fp=$(get_active_fingerprint 2>/dev/null) || active_fp=""

    echo ""
    echo -e "${BOLD}  Select account:${NC}"
    echo ""

    local i=1
    local names=()
    for file in "${profiles[@]}"; do
      local pname=$(basename "$file" .json)
      names+=("$pname")
      local fp=$(get_profile_fingerprint "$file" 2>/dev/null)
      local info=$(get_profile_info "$file" 2>/dev/null)
      local sub_type=$(echo "$info" | cut -d'|' -f1)
      local label_file="$ACCOUNTS_DIR/${pname}.label"
      local label=""
      [[ -f "$label_file" ]] && label=" ${DIM}($( cat "$label_file"))${NC}"

      if [[ "$fp" == "$active_fp" ]]; then
        echo -e "  ${GREEN}$i)${NC} ${BOLD}$pname${NC}  $(format_sub_type "$sub_type")${label}  ${GREEN}← active${NC}"
      else
        echo -e "  $i) ${BOLD}$pname${NC}  $(format_sub_type "$sub_type")${label}"
      fi
      ((i++))
    done

    echo ""
    read -rp "  Enter number (or q to cancel): " choice

    if [[ "$choice" == "q" || -z "$choice" ]]; then
      echo "  Cancelled."
      return 0
    fi

    if [[ "$choice" -ge 1 && "$choice" -le "${#names[@]}" ]] 2>/dev/null; then
      name="${names[$((choice-1))]}"
    else
      echo -e "  ${RED}Invalid choice.${NC}"
      return 1
    fi
  fi

  name=$(echo "$name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local file="$ACCOUNTS_DIR/${name}.json"

  if [[ ! -f "$file" ]]; then
    echo -e "${RED}Profile '$name' not found.${NC}"
    echo "Available profiles:"
    ls "$ACCOUNTS_DIR"/*.json 2>/dev/null | xargs -I{} basename {} .json | sed 's/^/  /'
    return 1
  fi

  # Check if already active
  local active_fp=$(get_active_fingerprint 2>/dev/null)
  local target_fp=$(get_profile_fingerprint "$file" 2>/dev/null)
  if [[ "$active_fp" == "$target_fp" ]]; then
    echo -e "${YELLOW}Already on profile '$name'.${NC}"
    return 0
  fi

  local creds
  creds=$(cat "$file")
  write_keychain "$creds"

  local info=$(get_profile_info "$file" 2>/dev/null)
  local sub_type=$(echo "$info" | cut -d'|' -f1)
  local label_file="$ACCOUNTS_DIR/${name}.label"
  local label=""
  [[ -f "$label_file" ]] && label=$(cat "$label_file")

  echo -e "${GREEN}✓${NC} Switched to ${BOLD}$name${NC}  $(format_sub_type "$sub_type")"
  echo -e "${DIM}  All Claude Code sessions will use this account on their next API call.${NC}"

  log_activity "manual-switch" "to=${label:-$name}"
}

cmd_remove() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    echo -e "${RED}Usage: vdm remove <name>${NC}"
    return 1
  fi

  name=$(echo "$name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local file="$ACCOUNTS_DIR/${name}.json"

  if [[ ! -f "$file" ]]; then
    echo -e "${RED}Profile '$name' not found.${NC}"
    return 1
  fi

  rm -f "$file" "$ACCOUNTS_DIR/${name}.label"
  echo -e "${GREEN}✓${NC} Removed profile ${BOLD}$name${NC}"
}

cmd_status() {
  local creds
  creds=$(read_keychain 2>/dev/null) || {
    echo -e "${RED}No credentials found in Keychain.${NC}"
    return 1
  }

  local active_fp=$(get_active_fingerprint 2>/dev/null)

  # Find matching profile
  local active_name="(not saved)"
  for file in "$ACCOUNTS_DIR"/*.json; do
    [[ -f "$file" ]] || continue
    local fp=$(get_profile_fingerprint "$file" 2>/dev/null)
    if [[ "$fp" == "$active_fp" ]]; then
      active_name=$(basename "$file" .json)
      break
    fi
  done

  local info
  info=$(echo "$creds" | python3 -c "
import sys, json, datetime
d = json.load(sys.stdin)
oauth = d.get('claudeAiOauth', {})
sub = oauth.get('subscriptionType', 'unknown')
tier = oauth.get('rateLimitTier', 'unknown')
expires = oauth.get('expiresAt', 0)
exp_str = datetime.datetime.fromtimestamp(expires/1000).strftime('%Y-%m-%d %H:%M') if expires else 'unknown'
scopes = ', '.join(oauth.get('scopes', []))
print(f'{sub}|{tier}|{exp_str}|{scopes}')
")

  local sub_type=$(echo "$info" | cut -d'|' -f1)
  local tier=$(echo "$info" | cut -d'|' -f2)
  local expires=$(echo "$info" | cut -d'|' -f3)
  local scopes=$(echo "$info" | cut -d'|' -f4)

  # Fetch email
  local token
  token=$(echo "$creds" | python3 -c "import sys,json; print(json.load(sys.stdin)['claudeAiOauth']['accessToken'])" 2>/dev/null)
  local email=""
  if [[ -n "$token" ]]; then
    email=$(fetch_account_email "$token")
  fi

  echo ""
  echo -e "${BOLD}  Active Account${NC}"
  echo -e "  ────────────────────────────────"
  echo -e "  Profile:  ${BOLD}$active_name${NC}"
  if [[ -n "$email" ]]; then
    echo -e "  Email:    ${CYAN}$email${NC}"
  fi
  echo -e "  Plan:     $(format_sub_type "$sub_type")"
  echo -e "  Tier:     $tier"
  echo -e "  Expires:  $expires"
  echo -e "  Scopes:   ${DIM}$scopes${NC}"

  # Show proxy/auto-switch status
  local proxy_on=$(get_config_value "proxyEnabled")
  local auto_on=$(get_config_value "autoSwitch")
  local strategy=$(get_config_string "rotationStrategy")
  local interval=$(get_config_string "rotationIntervalMin")
  local notifs=$(get_config_value "notifications")
  echo ""
  echo -e "  ${BOLD}Settings${NC}"
  echo -e "  ────────────────────────────────"
  echo -e "  Proxy:         ${proxy_on:+${GREEN}ON${NC}}${proxy_on:-${DIM}OFF${NC}}"
  echo -e "  Auto-switch:   ${auto_on:+${GREEN}ON${NC}}${auto_on:-${DIM}OFF${NC}}"
  echo -e "  Notifications: ${notifs:+${GREEN}ON${NC}}${notifs:-${DIM}OFF${NC}}"
  echo -e "  Rotation:      ${CYAN}${strategy:-sticky}${NC}"
  if [[ "${strategy:-sticky}" == "round-robin" ]]; then
    echo -e "  Interval:      ${interval:-60} min"
  fi
  echo ""
}

cmd_config() {
  local key="${1:-}"
  local value="${2:-}"

  if [[ -z "$key" ]]; then
    # Show current config
    echo ""
    echo -e "${BOLD}  Settings${NC}"
    echo -e "  ────────────────────────────────"
    local proxy_on=$(get_config_value "proxyEnabled")
    local auto_on=$(get_config_value "autoSwitch")
    local strategy=$(get_config_string "rotationStrategy")
    local interval=$(get_config_string "rotationIntervalMin")
    if [[ "$proxy_on" == "True" ]]; then
      echo -e "  proxyEnabled:       ${GREEN}on${NC}"
    else
      echo -e "  proxyEnabled:       ${DIM}off${NC}"
    fi
    if [[ "$auto_on" == "True" ]]; then
      echo -e "  autoSwitch:         ${GREEN}on${NC}"
    else
      echo -e "  autoSwitch:         ${DIM}off${NC}"
    fi
    local notifs=$(get_config_value "notifications")
    if [[ "$notifs" == "True" ]]; then
      echo -e "  notifications:      ${GREEN}on${NC}"
    else
      echo -e "  notifications:      ${DIM}off${NC}"
    fi
    echo -e "  rotationStrategy:   ${CYAN}${strategy:-sticky}${NC}"
    echo -e "  rotationIntervalMin: ${interval:-60}"
    echo ""
    echo -e "  ${DIM}Usage: vdm config <key> <value>${NC}"
    echo -e "  ${DIM}  vdm config proxy on${NC}"
    echo -e "  ${DIM}  vdm config autoswitch off${NC}"
    echo -e "  ${DIM}  vdm config notifications off${NC}"
    echo -e "  ${DIM}  vdm config rotation sticky|conserve|round-robin|spread|drain-first${NC}"
    echo -e "  ${DIM}  vdm config interval 15|30|60|120${NC}"
    return 0
  fi

  # Normalize key
  local is_bool=true
  case "$key" in
    proxy|proxyEnabled|proxy-enabled)       key="proxyEnabled" ;;
    autoswitch|autoSwitch|auto-switch)    key="autoSwitch" ;;
    notifications|notifs)                 key="notifications" ;;
    rotation|rotationStrategy|strategy)   key="rotationStrategy"; is_bool=false ;;
    interval|rotationIntervalMin)         key="rotationIntervalMin"; is_bool=false ;;
    *)
      echo -e "${RED}Unknown setting: $key${NC}"
      echo "  Available: proxy, autoswitch, notifications, rotation, interval"
      return 1
      ;;
  esac

  if [[ -z "$value" ]]; then
    if [[ "$is_bool" == "true" ]]; then
      local current=$(get_config_value "$key")
      echo "$key = $current"
    else
      local current=$(get_config_string "$key")
      echo "$key = $current"
    fi
    return 0
  fi

  if [[ "$is_bool" == "true" ]]; then
    # Boolean setting
    case "$value" in
      on|true|1|yes)   value="True" ;;
      off|false|0|no)  value="False" ;;
      *)
        echo -e "${RED}Invalid value: $value${NC}  (use on/off)"
        return 1
        ;;
    esac
    set_config_value "$key" "$value"
    if [[ "$value" == "True" ]]; then
      echo -e "${GREEN}✓${NC} ${BOLD}$key${NC} = ${GREEN}on${NC}"
    else
      echo -e "${GREEN}✓${NC} ${BOLD}$key${NC} = ${DIM}off${NC}"
    fi
  elif [[ "$key" == "rotationStrategy" ]]; then
    case "$value" in
      sticky|conserve|round-robin|spread|drain-first) ;;
      *)
        echo -e "${RED}Invalid strategy: $value${NC}"
        echo "  Options: sticky, conserve, round-robin, spread, drain-first"
        return 1
        ;;
    esac
    set_config_string "$key" "$value"
    echo -e "${GREEN}✓${NC} ${BOLD}$key${NC} = ${CYAN}$value${NC}"
  elif [[ "$key" == "rotationIntervalMin" ]]; then
    case "$value" in
      15|30|60|120) ;;
      *)
        echo -e "${RED}Invalid interval: $value${NC}  (use 15, 30, 60, or 120)"
        return 1
        ;;
    esac
    set_config_number "$key" "$value"
    echo -e "${GREEN}✓${NC} ${BOLD}$key${NC} = ${CYAN}${value} min${NC}"
  fi

  log_activity "settings-changed" "$key=$value"
}

cmd_dashboard() {
  local action="${1:-start}"

  case "$action" in
    stop)
      # Try PID file first, then fall back to port-based detection
      local stopped=false
      if [[ -f "$DASHBOARD_PID_FILE" ]]; then
        local pid=$(cat "$DASHBOARD_PID_FILE")
        if kill "$pid" 2>/dev/null; then
          stopped=true
        fi
        rm -f "$DASHBOARD_PID_FILE"
      fi
      if [[ "$stopped" != "true" ]]; then
        # Find by port
        local pid
        pid=$(lsof -iTCP:"$DASHBOARD_PORT" -sTCP:LISTEN -t 2>/dev/null | head -1) || true
        if [[ -n "$pid" ]]; then
          kill "$pid" 2>/dev/null
          stopped=true
        fi
      fi
      if [[ "$stopped" == "true" ]]; then
        echo -e "${GREEN}✓${NC} Dashboard stopped."
      else
        echo -e "${YELLOW}Dashboard was not running.${NC}"
      fi
      ;;
    start|"")
      # Check if already running (by PID file or port)
      if [[ -f "$DASHBOARD_PID_FILE" ]]; then
        local pid=$(cat "$DASHBOARD_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
          echo -e "${YELLOW}Dashboard already running at http://localhost:$DASHBOARD_PORT${NC}"
          echo -e "${DIM}Use 'vdm dashboard stop' to stop it.${NC}"
          return 0
        fi
        rm -f "$DASHBOARD_PID_FILE"
      fi
      # Also check by port
      if lsof -iTCP:"$DASHBOARD_PORT" -sTCP:LISTEN -t >/dev/null 2>&1; then
        echo -e "${YELLOW}Dashboard already running at http://localhost:$DASHBOARD_PORT${NC}"
        echo -e "${DIM}Use 'vdm dashboard stop' to stop it.${NC}"
        return 0
      fi

      echo -e "${BLUE}Starting dashboard on http://localhost:$DASHBOARD_PORT${NC}"
      node "$SCRIPT_DIR/dashboard.mjs" &
      local pid=$!
      echo "$pid" > "$DASHBOARD_PID_FILE"

      # Wait a moment then open
      sleep 0.5
      if kill -0 "$pid" 2>/dev/null; then
        echo -e "${GREEN}✓${NC} Dashboard running (PID $pid)"
        echo -e "  Dashboard: ${CYAN}http://localhost:$DASHBOARD_PORT${NC}"
        echo -e "  API Proxy: ${CYAN}http://localhost:$PROXY_PORT${NC}"
        open "http://localhost:$DASHBOARD_PORT" 2>/dev/null || echo -e "  Open http://localhost:$DASHBOARD_PORT in your browser"
      else
        echo -e "${RED}Dashboard failed to start. Check Node.js is installed.${NC}"
        rm -f "$DASHBOARD_PID_FILE"
        return 1
      fi
      ;;
    *)
      echo -e "${RED}Usage: vdm dashboard [start|stop]${NC}"
      ;;
  esac
}

cmd_upgrade() {
  local REPO_URL="https://github.com/loekj/claude-acct-switcher.git"
  local tmpdir
  tmpdir=$(mktemp -d)
  # Ensure cleanup on any exit from this function
  trap "rm -rf '$tmpdir'" RETURN

  echo ""
  echo -e "${BOLD}  Upgrading Van Damme-o-Matic…${NC}"
  echo ""

  # Fetch latest from remote
  echo -e "  ${DIM}Fetching latest version…${NC}"
  if ! git clone --depth 1 "$REPO_URL" "$tmpdir" 2>/dev/null; then
    echo -e "  ${RED}Failed to fetch from $REPO_URL${NC}"
    return 1
  fi

  # Compare versions (use git short hash as version marker)
  local current_hash=""
  if [[ -f "$SCRIPT_DIR/.version" ]]; then
    current_hash=$(cat "$SCRIPT_DIR/.version")
  fi
  local latest_hash
  latest_hash=$(git -C "$tmpdir" rev-parse --short HEAD 2>/dev/null)

  if [[ -n "$current_hash" && "$current_hash" == "$latest_hash" ]]; then
    echo -e "  ${GREEN}✓${NC} Already on the latest version (${DIM}$current_hash${NC})"
    return 0
  fi

  # Verify the fetched repo has the files we need
  for f in vdm dashboard.mjs lib.mjs; do
    if [[ ! -f "$tmpdir/$f" ]]; then
      echo -e "  ${RED}Fetched repo is missing $f — aborting.${NC}"
      return 1
    fi
  done

  # Check if dashboard is running (PID file or listening on port)
  local dashboard_was_running=false
  if [[ -f "$DASHBOARD_PID_FILE" ]] && kill -0 "$(cat "$DASHBOARD_PID_FILE")" 2>/dev/null; then
    dashboard_was_running=true
  elif lsof -iTCP:"$DASHBOARD_PORT" -sTCP:LISTEN -t >/dev/null 2>&1; then
    dashboard_was_running=true
  fi

  # Stop dashboard before overwriting files
  if [[ "$dashboard_was_running" == "true" ]]; then
    echo -e "  ${DIM}Stopping dashboard…${NC}"
    cmd_dashboard stop
    # Also kill any process on the port not tracked by PID file (e.g. shell auto-start)
    local port_pid
    port_pid=$(lsof -iTCP:"$DASHBOARD_PORT" -sTCP:LISTEN -t 2>/dev/null | head -1) || true
    if [[ -n "$port_pid" ]]; then
      kill "$port_pid" 2>/dev/null || true
    fi
  fi

  # Overwrite only code files — never touch accounts/, config.json,
  # activity-log.json, .label files, or any other user data.
  echo -e "  ${DIM}Updating files…${NC}"
  cp "$tmpdir/vdm"          "$SCRIPT_DIR/vdm"
  cp "$tmpdir/dashboard.mjs" "$SCRIPT_DIR/dashboard.mjs"
  cp "$tmpdir/lib.mjs"      "$SCRIPT_DIR/lib.mjs"
  chmod +x "$SCRIPT_DIR/vdm"

  # Write version marker
  echo "$latest_hash" > "$SCRIPT_DIR/.version"

  # Restart dashboard if it was running
  if [[ "$dashboard_was_running" == "true" ]]; then
    echo -e "  ${DIM}Restarting dashboard…${NC}"
    cmd_dashboard start
  fi

  echo ""
  if [[ -n "$current_hash" ]]; then
    echo -e "  ${GREEN}✓${NC} Upgraded ${DIM}$current_hash${NC} → ${BOLD}$latest_hash${NC}"
  else
    echo -e "  ${GREEN}✓${NC} Upgraded to ${BOLD}$latest_hash${NC}"
  fi
  echo ""

  log_activity "upgrade" "from=${current_hash:-unknown}" "to=$latest_hash"
}

cmd_help() {
  echo ""
  echo -e "${BOLD}  vdm${NC}  - Van Damme-o-Matic"
  echo ""
  echo -e "  ${BOLD}USAGE${NC}"
  echo -e "    vdm <command> [args]"
  echo ""
  echo -e "  ${BOLD}COMMANDS${NC}"
  echo -e "    ${CYAN}list${NC}                    List all saved profiles"
  echo -e "    ${CYAN}switch${NC} [name]           Switch to a profile (interactive if no name)"
  echo -e "    ${CYAN}remove${NC} <name>           Delete a saved profile"
  echo -e "    ${CYAN}status${NC}                  Show current account details + settings"
  echo -e "    ${CYAN}config${NC} [key] [on|off]   View or toggle settings (proxy, autoswitch)"
  echo -e "    ${CYAN}dashboard${NC} [start|stop]  Launch/stop the web dashboard"
  echo -e "    ${CYAN}upgrade${NC}                 Update to the latest version"
  echo -e "    ${CYAN}help${NC}                    Show this help"
  echo ""
  echo -e "  ${BOLD}QUICK START${NC}"
  echo -e "    1. Log in to account A:  ${DIM}claude login${NC}"
  echo -e "    2. Log in to account B:  ${DIM}claude login${NC}"
  echo -e "    3. That's it. Accounts are auto-discovered and labeled."
  echo -e "    4. Switch anytime:       ${DIM}vdm switch${NC}"
  echo ""
  echo -e "  ${BOLD}SETTINGS${NC}"
  echo -e "    ${DIM}vdm config proxy on${NC}       Enable auth-swapping proxy"
  echo -e "    ${DIM}vdm config proxy off${NC}      Passthrough mode (no token swap)"
  echo -e "    ${DIM}vdm config autoswitch off${NC}  Disable auto-switch on 429/401"
  echo ""
  echo -e "  ${BOLD}HOW IT WORKS${NC}"
  echo -e "    Accounts are auto-discovered when you run ${DIM}claude login${NC}."
  echo -e "    The proxy (port ${PROXY_PORT}) auto-switches on rate limits."
  echo -e "    Emails are fetched automatically  - no manual labeling needed."
  echo ""
}

# ─────────────────────────────────────────────────────────
# Main dispatch
# ─────────────────────────────────────────────────────────

command="${1:-help}"
shift 2>/dev/null || true

case "$command" in
  add)       cmd_add "$@" ;;
  label)     cmd_label "$@" ;;
  list|ls)   cmd_list ;;
  switch|sw) cmd_switch "$@" ;;
  remove|rm) cmd_remove "$@" ;;
  status|st) cmd_status ;;
  config|cfg) cmd_config "$@" ;;
  dashboard) cmd_dashboard "$@" ;;
  upgrade|update) cmd_upgrade ;;
  help|--help|-h) cmd_help ;;
  *)
    echo -e "${RED}Unknown command: $command${NC}"
    cmd_help
    exit 1
    ;;
esac
